- efficient_k may be the vulnerable part of the program
- flag = 66 6C 61 67
=> find a hexstring for which shake_128 return something similar AKA a collision
=> find out how os.urandom work
OR
=> use an arbitrary string which is encoded but os.urandom gives a high chance it will create a collision with the k for "flag"
OR
=> calculate the private key from the message and the signature

Possible solution:
- it is possible to recover the public key with the signature and the used message
=> with the public key probably the sign function of the ecdsa encryptor can be reversed
=> a problem might be the random k
